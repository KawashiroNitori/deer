# -*- mode: shell-script -*-
# vim: set ft=zsh :
#########################################################################
# Copyright (C) 2014  Wojciech Siewierski                               #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

zstyle -s ":deer:" height DEER_HEIGHT || DEER_HEIGHT=22

# Select the Nth next file. Pass a negative argument for the previous file.
deer-move()
{
    local FILES MOVEMENT INDEX
    MOVEMENT=$1

    FILES=($DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-/:t) $DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-^/:t))

    INDEX=${(k)FILES[(re)$DEER_BASENAME]}

    if (( INDEX+MOVEMENT <= 0 )); then
        DEER_BASENAME=$FILES[1]
    elif (( INDEX+MOVEMENT > $#FILES )); then
        DEER_BASENAME=$FILES[$#FILES]
    else
        DEER_BASENAME=$FILES[$INDEX+$MOVEMENT]
    fi
}

# Enter a selected directory and optionally apply a new file filter.
deer-enter()
{
    [ -n "$DEER_BASENAME" -a -d "$DEER_DIRNAME/$DEER_BASENAME" ] || return

    DEER_DIRNAME=$DEER_DIRNAME$DEER_BASENAME/

    case $1 in
        --filter)
            DEER_FILTER[$DEER_DIRNAME]=$2
            shift 2
            ;;
    esac

    # get the first directory
    DEER_BASENAME=($DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-/:t) $DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-^/:t))
    DEER_BASENAME=$DEER_BASENAME[1]
}

# Leave the directory and reset the file filter.
deer-leave()
{
    [ $DEER_DIRNAME = / ] && return
    DEER_BASENAME=$DEER_DIRNAME:t
    DEER_DIRNAME=$DEER_DIRNAME:h
    [ $DEER_DIRNAME = / ] || DEER_DIRNAME+=/

    DEER_FILTER[$DEER_DIRNAME]=${DEER_FILTER[$DEER_DIRNAME]:-'*'}
}

# Display a given prompt, read a string and save it into $BUFFER.
deer-prompt()
{
    BUFFER=""
    PREDISPLAY="$1/ "

    local old_region_highlight
    old_region_highlight=($region_highlight)
    region_highlight=("P0 $#1 fg=green")
    zle recursive-edit
    region_highlight=($old_region_highlight)
}

# Read a pattern and select the first matching file.
deer-search()
{
    local OLD_BASENAME=$DEER_BASENAME
    deer-prompt "search"

    DEER_BASENAME=($DEER_DIRNAME/${~BUFFER}${~DEER_FILTER[$DEER_DIRNAME]}(N-:t))
    DEER_BASENAME=${DEER_BASENAME[1]:-$OLD_BASENAME}
}

# Read a pattern and use it as a new filter.
deer-filter()
{
    local OLD_BASENAME=$DEER_BASENAME
    deer-prompt "filter"

    local TMP_FILTER
    if [ -n "$BUFFER" ]; then
        TMP_FILTER=*$BUFFER*
    else
        TMP_FILTER=*
    fi

    deer-leave
    deer-enter --filter $TMP_FILTER
    if [ -z "$DEER_BASENAME" ]; then
        deer-leave
        deer-enter --filter '*'
    fi
}

# Draw an arrow pointing to the selected file.
deer-mark-file-list()
{
    local MARKED=$1
    shift

    print -l -- "$@" \
        | grep -Fx -B5 -A$DEER_HEIGHT -- "$MARKED" \
        | perl -pe 'BEGIN{$name = shift}
                    if ($name."\n" eq $_) {
                        $_="-> $_"
                    } else {
                        $_="   $_"
                    }' -- "$MARKED"
}

# Draw the file lists in the form of Miller columns.
deer-preview()
{
    local FILES PREVIEW PARENTFILES OUTPUT
    local SEPARATOR="------"

    PREDISPLAY=$OLD_LBUFFER
    LBUFFER=$DEER_DIRNAME$DEER_BASENAME
    RBUFFER=""
    region_highlight=("P0 $#PREDISPLAY fg=black,bold"
                      "0 $#DEER_DIRNAME fg=blue,bold")


    FILES=($DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-/:t)
           $SEPARATOR
           $DEER_DIRNAME/${~DEER_FILTER[$DEER_DIRNAME]}(N-^/:t))
    PARENTFILES=($DEER_DIRNAME:h/${~DEER_FILTER[$DEER_DIRNAME:h/]:-'*'}(N-/:t))

    local IFS=$'\n'
    FILES=($(deer-mark-file-list "$DEER_BASENAME" $FILES))
    PARENTFILES=($(deer-mark-file-list "$DEER_DIRNAME:t" $PARENTFILES))
    unset IFS

    FILES=(${(F)FILES[1,$DEER_HEIGHT]})
    PARENTFILES=(${(F)PARENTFILES[1,$DEER_HEIGHT]})


    if [ -f $DEER_DIRNAME/$DEER_BASENAME ]; then
        if file $DEER_DIRNAME/$DEER_BASENAME | grep -Fq text; then
            PREVIEW="--- Preview: ---"$'\n'$(head -n$DEER_HEIGHT $DEER_DIRNAME/$DEER_BASENAME)

            # Replace '/' with '\' to allow using it as a
            # paste(1)/column(1) separator.
            PREVIEW=${PREVIEW//\//\\}
        else
            PREVIEW="--- Binary file, preview unavailable ---"
        fi
    else
        PREVIEW=($DEER_DIRNAME/$DEER_BASENAME/${~DEER_FILTER[$DEER_DIRNAME$DEER_BASENAME/]:-'*'}(N-/:t)
                 $SEPARATOR
                 $DEER_DIRNAME/$DEER_BASENAME/${~DEER_FILTER[$DEER_DIRNAME$DEER_BASENAME/]:-'*'}(N-^/:t))
        PREVIEW=${(F)PREVIEW[1,$DEER_HEIGHT]}
    fi

    OUTPUT="$(paste -d/ <(<<< $PARENTFILES                   \
                            | awk '{print substr($0,1,16)}') \
                        <(<<< $FILES)                        \
                        <(<<< $PREVIEW)                      \
                | sed 's,/, / ,g'                            \
                | column -t -s/                              \
                | awk -v width=$COLUMNS '{print substr($0,1,width-1)}')"
    zle -M -- $OUTPUT
    zle -R
}

# Run `deer-add' with the same arguments, restore the shell state and
# then exit.
deer-restore()
{
    deer-add "$@"
    PREDISPLAY=""
    region_highlight=()
    LBUFFER=$OLD_LBUFFER
    RBUFFER=$OLD_RBUFFER
    zle redisplay
    zle -M ""
}

# Add the given string before or after the cursor.
deer-add()
{
    case $1 in
        --append)
            OLD_LBUFFER+=$2
            shift 2
            ;;
        --insert)
            OLD_RBUFFER=$2$OLD_RBUFFER
            shift 2
            ;;
    esac
}

# Get the quoted relative path from the absolute unquoted path.
deer-get-relative()
{
    local TMP
    TMP=${1:-$DEER_DIRNAME$DEER_BASENAME}
    TMP="`realpath --no-symlinks --relative-to=. $TMP`"
    print -R $TMP:q
}

# The main entry function.
deer-launch()
{
    emulate -L zsh
    local DEER_DIRNAME DEER_BASENAME
    local REPLY OLD_LBUFFER OLD_RBUFFER
    local -A DEER_FILTER

    OLD_LBUFFER=$LBUFFER
    OLD_RBUFFER=$RBUFFER

    DEER_DIRNAME=$PWD
    if [ -n "$NUMERIC" ]; then
        for i in {1..$NUMERIC}; do
            deer-leave
        done
    else
        # Don't change cwd but initialize the variables.
        deer-leave
        deer-enter --filter ${DEER_FILTER[$DEER_DIRNAME]:-'*'}
    fi

    deer-preview
    while read -k; do
        case $REPLY in
            # Movement
            k)
                deer-move -1
                deer-preview
                ;;
            K)
                deer-move -5
                deer-preview
                ;;
            j)
                deer-move 1
                deer-preview
                ;;
            J)
                deer-move 5
                deer-preview
                ;;
            # Enter the selected directory and reset the filter.
            l)
                deer-enter --filter ${DEER_FILTER[$DEER_DIRNAME$DEER_BASENAME/]:-'*'}
                deer-preview
                ;;
            # Leave the directory and implicitly reset the filter.
            h|$'\014')          # \014 is Ctrl+L, from Helm for Emacs
                deer-leave
                deer-preview
                ;;
            # Search
            /)
                deer-search
                deer-preview
                ;;
            # Filter
            f)
                deer-filter
                deer-preview
                ;;
            # Quit
            q)
                deer-restore
                break
                ;;
            # Insert the path and quit.
            a)
                deer-restore --append "`deer-get-relative`"
                break
                ;;
            A)
                deer-restore --append $DEER_DIRNAME:q$DEER_BASENAME:q
                break
                ;;
            i)
                deer-restore --insert "`deer-get-relative`"
                break
                ;;
            I)
                deer-restore --insert $DEER_DIRNAME:q$DEER_BASENAME:q
                break
                ;;
            # Insert the path and don't quit yet.
            s)
                deer-add --append "`deer-get-relative`"${OLD_LBUFFER[-1]:- }
                deer-preview
                ;;
            S)
                deer-add --append $DEER_BASENAME:q${OLD_LBUFFER[-1]:- }
                deer-preview
                ;;
            # Quit and change the shell's current directory to the selected one.
            c)
                deer-leave
                ;&
            C)
                if [[ -d $DEER_DIRNAME$DEER_BASENAME && -x $DEER_DIRNAME$DEER_BASENAME ]]; then
                    cd -- $DEER_DIRNAME$DEER_BASENAME
                    deer-restore
                    break
                fi
                ;;
            # See rifle(1) manpage (included with ranger(1)).
            r)
                rifle $DEER_DIRNAME$DEER_BASENAME
                ;;
        esac
    done
}

zle && deer-launch
