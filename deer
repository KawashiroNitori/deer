# -*- mode: shell-script -*-
# vim: set ft=zsh :
#########################################################################
# Copyright (C) 2014  Wojciech Siewierski                               #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

DEER_HEIGHT=22

deer-move()
{
    local FILES DIRECTION COUNT
    DIRECTION=$1
    COUNT=${2:-1}

    FILES=($DEER_DIRNAME/*(N:t))

    case $DIRECTION in
        up)
            DEER_BASENAME="$(print -l $FILES | grep -Fx -B$COUNT -m1 "$DEER_BASENAME" | head -n1)"
            ;;
        down)
            DEER_BASENAME="$(print -l $FILES | grep -Fx -A$COUNT -m1 "$DEER_BASENAME" | tail -n1)"
            ;;
    esac
}

deer-enter()
{
    [ -d $DEER_DIRNAME/$DEER_BASENAME ] || return

    DEER_DIRNAME=$DEER_DIRNAME$DEER_BASENAME/

    # get the first directory
    DEER_BASENAME=($DEER_DIRNAME/*(N:t))
    DEER_BASENAME=$DEER_BASENAME[1]
}

deer-leave()
{
    [ $DEER_DIRNAME = / ] && return
    DEER_BASENAME=$DEER_DIRNAME:t
    DEER_DIRNAME=$DEER_DIRNAME:h
    [ $DEER_DIRNAME = / ] || DEER_DIRNAME+=/
}

deer-search()
{
    local OLD_BASENAME=$DEER_BASENAME
    BUFFER=""
    PREDISPLAY="deer/ "
    zle recursive-edit
    DEER_BASENAME=($DEER_DIRNAME/${~BUFFER}*(N:t))
    DEER_BASENAME=${DEER_BASENAME[1]:-$OLD_BASENAME}
    PREDISPLAY="deer: "
}

deer--mark-file-list()
{
    local MARKED=$1
    shift

    print -l "$@" \
        | grep -Fx -B5 -A$DEER_HEIGHT -m1 -- "$MARKED" \
        | perl -pe 'BEGIN{$name = shift}
                    if ($name."\n" eq $_) {
                        $_="-> $_"
                    } else {
                        $_="   $_"
                    }' -- "$MARKED"
}

deer-preview()
{
    local FILES PREVIEW PARENTFILES OUTPUT

    LBUFFER=$DEER_DIRNAME
    RBUFFER=$DEER_BASENAME


    FILES=($DEER_DIRNAME/*(N:t))
    PARENTFILES=($DEER_DIRNAME:h/*(N:t))

    local IFS=$'\n'
    FILES=($(deer--mark-file-list "$DEER_BASENAME" $FILES))
    PARENTFILES=($(deer--mark-file-list "$DEER_DIRNAME:t" $PARENTFILES))
    unset IFS

    FILES=(${(F)FILES[1,$DEER_HEIGHT]})
    PARENTFILES=(${(F)PARENTFILES[1,$DEER_HEIGHT]})


    if [ -f $DEER_DIRNAME/$DEER_BASENAME ]; then
        if file $DEER_DIRNAME/$DEER_BASENAME | grep -Fq text; then
            PREVIEW="--- Preview: ---"$'\n'$(head -n$DEER_HEIGHT $DEER_DIRNAME/$DEER_BASENAME)

            # Replace '/' with '\' to allow using it as a
            # paste(1)/column(1) separator.
            PREVIEW=${PREVIEW//\//\\}
        else
            PREVIEW="--- Binary file, preview unavailable ---"
        fi
    else
        PREVIEW=($DEER_DIRNAME/$DEER_BASENAME/*(N:t))
        PREVIEW=${(F)PREVIEW[1,$DEER_HEIGHT]}
    fi

    OUTPUT="$(paste -d/ <(<<< $PARENTFILES | cut -c 1-16) \
                        <(<<< $FILES)                     \
                        <(<<< $PREVIEW)                   \
                | column -t -s/                           \
                | cut -c 1-$[COLUMNS-1])"
    zle -M -- $OUTPUT
    zle -R
}

deer-launch()
{
    local REPLY OLD_LBUFFER OLD_RBUFFER

    OLD_LBUFFER=$LBUFFER
    OLD_RBUFFER=$RBUFFER
    PREDISPLAY="deer: "

    DEER_DIRNAME=$PWD
    deer-leave

    deer-preview
    while read -k; do
        case $REPLY in
            k)
                deer-move up 1
                deer-preview
                ;;
            K)
                deer-move up 5
                deer-preview
                ;;
            j)
                deer-move down 1
                deer-preview
                ;;
            J)
                deer-move down 5
                deer-preview
                ;;
            l)
                deer-enter
                deer-preview
                ;;
            h|$'\014')          # \014 is Ctrl+L, from Helm for Emacs
                deer-leave
                deer-preview
                ;;

            /)
                deer-search
                deer-preview
                ;;

            q)
                deer-restore
                break
                ;;
            i)
                deer-restore $BUFFER
                break
                ;;
            c)
                if [[ -d $BUFFER && -x $BUFFER ]]; then
                    cd -- $BUFFER
                    deer-restore
                    break
                fi
                ;;
        esac
    done
}
zle -N deer-launch

deer-restore()
{
    PREDISPLAY=""
    LBUFFER=$OLD_LBUFFER
    RBUFFER=$OLD_RBUFFER
    [ -n "$1" ] && LBUFFER+=$1
    zle redisplay
    zle -M ""
}

bindkey '\ek' deer-launch
